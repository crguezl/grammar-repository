A context-free language is inherently ambiguous if all context-free
grammars generating that language are ambiguous.  While some
context-free languages  have both ambiguous and unambiguous grammars, there
are context-free languages for which no unambiguous context-free
grammar can exist. An example of an inherently ambiguous language
is the set 

\[\{ a^n b^m c^r \mbox{ such that } n = m \mbox{ or } m = r \mbox{ and } n,m,r \ge 0 \} \]

\noindent which is context-free, since it is generated and \underline{solved} by the following grammar
\verb|AmbiguousLanguage1.eyp| (download it from \cite{lgforte}):

\begin{center}
\begin{tabular}{p{6.3cm}}
\begin{VERBATIM}
\textbf{%token AB=%//=ab}      \label{vrb:tokenAB}
%token a b c          \label{vrb:tokensabc}
%%
s:    \textbf{AB} aeqb     | beqc   ; \label{vrb:useoftokenAB}
aeqb: ab cs                ;
\textbf{ab}:   \textit{/* empty */} | a ab b ; \label{vrb:ab}
cs :  \textit{/* empty */} | cs c   ;
beqc: as bc                ;
bc:   \textit{/* empty */} | b bc c ;
as:   \textit{/* empty */} | as a   ; 
%%
\end{VERBATIM}
\end{tabular}
\end{center}

The syntactic variable  \verb|aeqb| correspond to guess that there are the same number of \verb|a|s than \verb|b|s.
In the same way, \verb|beqc| starts the subgrammar for those phrases where the number of \verb|b|s is equal
to the number of \verb|c|s. The usual grammar designer approach to eliminate the ambiguity by changing the grammar to an unambiguous one 
simply does not work.
Such grammar does not exist and will never be found. Observe, however, that the language is not an exotic one.
In fact, some usefull languages contain this kind of constructs. When parsing such languages the programmer has 
no other way than to resort to semantic actions to check that the constraints are satisfied. 
But this approach implies that we can't cleanly separate syntactic analysis and semantic actions for such kind of languages. 

To help the parser, we create a fictitious token \verb|AB| which is used at line \ref{vrb:useoftokenAB} to decide
which of the two productions applies. 
The empty regular expression \verb|//| for token \verb|AB| always 
matches
but the token will be generated by the lexical analyzer 
only when expected by the syntax analyzer (the definition uses the \verb|%/ ... /| notation) 
and when the incoming input matches the \verb|ab| language 
(defined at line \ref{vrb:ab}), that is, when the number of \verb|a|'s matches the number of \verb|b|s (use of
the notation \verb|/ ... /=ab|).
