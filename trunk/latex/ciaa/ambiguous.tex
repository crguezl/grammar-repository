A context-free language is inherently ambiguous if all context-free
grammars generating that language are ambiguous.  While some
context-free languages  have both ambiguous and unambiguous grammars, there
are context-free languages for which no unambiguous context-free
grammar can exist. An example of an inherently ambiguous language
is the set 

\[\{ a^n b^m c^r \mbox{ such that } n = m \mbox{ or } m = r \mbox{ and } n,m,r \ge 0 \} \]

\noindent which is context-free, since it is generated by the following grammar:

\begin{center}
\begin{tabular}{p{6.3cm}}
\begin{VERBATIM}
%%
s: aeqb | beqc ;
aeqb: ab cs ;
ab: \textit{/* empty */} | 'a' ab 'b' ;
cs: \textit{/* empty */} | cs 'c' ;
beqc: as bc ;
bc: \textit{/* empty */} | 'b' bc 'c' ;
as: \textit{/* empty */} | as 'a' ; \label{vrb:as}
%%
\end{VERBATIM}
\end{tabular}
\end{center}

The symbol \verb|aeqb| correspond to guess that there are the same number of \verb|a|s than \verb|b|s.
In the same way, \verb|beqc| starts the subgrammar for those phrases where the number of \verb|b|s is equal
to the number of \verb|c|s. The usual approach to eliminate the ambiguity by changing the grammar to an unambiguous one does not work.
Such grammar does not exist and will never be found. Observe, however, that the language is not an exotic one.
In fact, some usefull languages contain this kind of constructs. When parsing such languages the programmer has 
no other way than to resort to semantic actions to check that the constraints are satisfied. 
But this approach implies that we can't cleanly separate syntactic analysis and semantic actions for such kind of languages. 

The ambiguity above is pointed out by the compiler as a shift-reduce conflict in the presence of token 
\verb|'a'|:
\begin{itemize}
\item We can \verb|reduce| by production {\tt as: \textit{/* empty */}} (line \ref{vrb:as}), meaning that we  will consider the sequence of \verb|a|
as a free sequence, and we commit to option \verb|beqc|
or 
\item
We can \verb|shift| from item \verb|ab: .'a' ab 'b'| to \verb|ab: 'a'. ab 'b'|, in whose case, we choose to follow 
via \verb|aeqc|
\end{itemize}
Using PPCR the yacc programmer keeps control of the specific AST to build, either via \verb|aeqb| or via \verb|beqc|. 
The high-level PPCR solution below gives preference to \verb|aeqb|.
By changing the conflict resolution directive at line \ref{vrb:conflictAorC} below by:
\begin{verbatim}
         %conflict AorC bc? BC : shift
\end{verbatim}
we give preference to \verb|beqc| trees instead.
\begin{center}
\begin{tabular}{p{6.8cm}}
\begin{VERBATIM}
  \textbf{%conflict AorC ab? shift: BC} \label{vrb:conflictAorC}
  %%
  st:  \textbf{%AorC?} s ;
  s: aeqb | beqc ;
  aeqb: ab cs ;
  \textbf{ab}: /* empty */ 
    | 'a'         \textbf{%PREC AorC} ab 'b'
  ;
  cs: /* empty */ | cs 'c' ;
  beqc: as bc ;
  bc: /* empty */ | 'b' bc 'c' ;
  as: \textbf{%name BC}
      /* empty */ \textbf{%PREC AorC}
    | as 'a'
  ;
  %%
\end{VERBATIM}
\end{tabular}
\end{center}
